import { SkeletonServer } from './skeleton.js';
import { Bus } from '@aurora-is-near/borealis';
import { pg } from '../database.js';
import { Request } from '../request.js';
import * as web3 from '../web3.js';
interface Filter {
    id: string;
    type: string;
    block_hash?: string;
    poll_block?: web3.Quantity;
    from_block?: web3.Quantity;
    to_block?: web3.Quantity;
    addresses?: string | string[];
    topics?: web3.FilterTopic[];
}
export declare class DatabaseServer extends SkeletonServer {
    protected pgClient?: pg.Client;
    protected bus?: Bus;
    protected filtersKV?: any;
    protected _init(): Promise<void>;
    protected _query(query: string | /*sql.SelectStatement*/ any, args?: unknown[]): Promise<pg.QueryResult<any>>;
    eth_blockNumber(_request: Request): Promise<web3.Quantity>;
    eth_chainId(_request: Request): Promise<web3.Quantity>;
    eth_coinbase(_request: Request): Promise<web3.Data>;
    eth_getBlockByHash(_request: Request, blockHash: web3.Data, fullObject?: boolean): Promise<web3.BlockResult | null>;
    eth_getBlockByNumber(_request: Request, blockNumber: web3.Quantity | web3.Tag, fullObject?: boolean): Promise<web3.BlockResult | null>;
    eth_getBlockTransactionCountByHash(_request: Request, blockHash: web3.Data): Promise<web3.Quantity | null>;
    eth_getBlockTransactionCountByNumber(_request: Request, blockNumber: web3.Quantity | web3.Tag): Promise<web3.Quantity | null>;
    eth_getFilterChanges(_request: Request, filterID: web3.Quantity): Promise<web3.LogObject[]>;
    eth_getFilterLogs(_request: Request, filterID: web3.Quantity): Promise<web3.LogObject[]>;
    eth_getLogs(_request: Request, filter: web3.FilterOptions): Promise<web3.LogObject[]>;
    eth_getTransactionByBlockHashAndIndex(_request: Request, blockHash: web3.Data, transactionIndex: web3.Quantity): Promise<web3.TransactionResult | null>;
    eth_getTransactionByBlockNumberAndIndex(_request: Request, blockNumber: web3.Quantity | web3.Tag, transactionIndex: web3.Quantity): Promise<web3.TransactionResult | null>;
    eth_getTransactionByHash(_request: Request, transactionHash: web3.Data): Promise<web3.TransactionResult | null>;
    eth_getTransactionReceipt(_request: Request, transactionHash: string): Promise<web3.TransactionReceipt | null>;
    eth_getUncleCountByBlockHash(_request: Request, blockHash: web3.Data): Promise<web3.Quantity | null>;
    eth_getUncleCountByBlockNumber(_request: Request, blockNumber: web3.Quantity | web3.Tag): Promise<web3.Quantity | null>;
    eth_newBlockFilter(_request: Request): Promise<web3.Quantity>;
    eth_newFilter(_request: Request, filter: web3.FilterOptions): Promise<web3.Quantity>;
    eth_newPendingTransactionFilter(_request: Request): Promise<web3.Quantity>;
    eth_subscribe(_request: Request, _subsciptionType: web3.Data, _filter: any): Promise<web3.Data>;
    eth_uninstallFilter(_request: Request, filterID: web3.Quantity): Promise<boolean>;
    eth_unsubscribe(_request: Request, _subsciptionId: web3.Data): Promise<boolean>;
    protected _storeFilter(filter: Filter): Promise<void>;
    protected _getFilter(filterID: string): Promise<Filter>;
    protected _getFilterChangesEvent(filter: Filter): Promise<web3.LogObject[]>;
    protected _fetchCurrentBlockID(): Promise<bigint>;
    protected _fetchEvents(transactionID: Uint8Array): Promise<unknown[]>;
    protected _fetchTransactions(blockID: bigint | number | Uint8Array, fullObject: boolean): Promise<unknown[] | string[]>;
}
export {};
